Java线程状态
   1.新建状态(New)
   2.就绪状态(Runnable)
   3.运行状态(Running)
   4.阻塞状态(Blocked)
   5.死亡状态（Dead）
 

分析死锁:
		1.首先找到这个java进程,可以使用jps命令,或者使用ps -ef |grep XXX查找
		2.使用jstack 进程号 查看
		
JVM运行过程中产生的一些比较重要的线程罗列如下：

Attach Listener:所属 JVM
		Attach Listener 线程是负责接收到外部的命令，而对该命令进行执行的并且吧结果返回给发送者。
		通常我们会用一些命令去要求jvm给我们一些反馈信息，如：java -version、jmap、jstack等等。 
		如果该线程在jvm启动的时候没有初始化，那么，则会在用户第一次执行jvm命令时，得到启动。
		
Signal Dispatcher:所属 JVM
		前面我们提到第一个Attach Listener线程的职责是接收外部jvm命令，当命令接收成功后，
		会交给signal dispather 线程去进行分发到各个不同的模块处理命令，并且返回处理结果。 
		signal dispather线程也是在第一次接收外部jvm命令时，进行初始化工作。

CompilerThread0:所属 JVM
		用来调用JITing，实时编译装卸class 。通常,jvm会启动多个线程来处理这部分工作，
		线程名称后面的数字也会累加，例如：CompilerThread1

Concurrent Mark-Sweep GC Thread:所属 JVM
		并发标记清除垃圾回收器（就是通常所说的CMS GC）线程,该线程主要针对于老年代垃圾回收
		。ps：启用该垃圾回收器，需要在jvm启动参数中加上： -XX:+UseConcMarkSweepGC	
		
DestroyJavaVM :所属 JVM
		执行main()的线程在main执行完后调用JNI中的 jni_DestroyJavaVM() 方法唤起DestroyJavaVM 线程.
		JVM在 Jboss 服务器启动之后，就会唤起DestroyJavaVM线程，处于等待状态，
		等待其它线程（java线程和native线程）退出时通知它卸载JVM。线程退出时，
		都会判断自己当前是否是整个JVM中最后一个非deamon线程，如果是，
		则通知DestroyJavaVM 线程卸载JVM。
		ps：
		扩展一下：
		1.如果线程退出时判断自己不为最后一个非deamon线程，那么调用thread->exit(false) ，并在其中抛出thread_end事件，jvm不退出。
		2.如果线程退出时判断自己为最后一个非deamon线程，那么调用before_exit() 方法，抛出两个事件：?
		事件1：thread_end 线程结束事件；
		事件2：VM的death事件。然后调用thread->exit(true) 方法，接下来把线程从active list卸下，删除线程等等一系列工作执行完成后，
		则通知正在等待的DestroyJavaVM 线程执行卸载JVM操作。

